<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="de"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../jacoco-resources/report.gif" type="image/gif"/><title>Tools.java</title><link rel="stylesheet" href="../../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=2;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">HashMapTest.testAdd(int, float, boolean) (29.05.2019 13:02:31)</a> &gt; <a href="../../index.html" class="el_group">CombTest</a> &gt; <a href="../index.html" class="el_bundle">src/main/java</a> &gt; <a href="index.source.html" class="el_package">jcomb.core.ipog</a> &gt; <span class="el_source">Tools.java</span></div><h1>Tools.java</h1><pre class="source lang-java linenums">package jcomb.core.ipog;

import java.util.Arrays;
import java.util.Iterator;
import java.util.function.BiConsumer;
import java.util.function.Function;

/**
 * A utility class for the IPO generation algorithm
 * 
 * @author Noah Zuch
 *
 */
public final class Tools {

  private Tools() {

  }



  /**
   * Converts the given value combination array into its index representation.
   * 
   * @param domainSizes The sizes of the parameter domains.
   * @param combination The value combination array to convert. Has to be at lest of size
   * max{parameters}.
   * @param parameters The parameters in combination to take into account, when creating the index.
   * @return The index of the value combination.
   */
  public static int packValues(int[] domainSizes, int[] combination, int[] parameters) {
<span class="fc" id="L32">    int index = combination[parameters[0]];</span>
<span class="fc bfc" id="L33" title="All 2 branches covered.">    for (int i = 1; i &lt; parameters.length; i++) {</span>
<span class="fc" id="L34">      int parameterIndex = parameters[i];</span>
<span class="fc" id="L35">      index = index * domainSizes[parameterIndex] + combination[parameterIndex];</span>
    }
<span class="fc" id="L37">    return index;</span>
  }



  /**
   * Converts the given value combination array into its index representation. But leaves out the
   * last parameter and its value.
   * 
   * @param domainSizes The sizes of the parameter domains.
   * @param combination The value combination array to convert. Has to be at lest of size
   * max{parameters}.
   * @param parameters The parameters in combination to take into account, when creating the index.
   * The last parameter in this array is ignored.
   * @return The index of the value combination.
   */
  public static int packValuesExceptLast(int[] domainSizes, int[] combination, int[] parameters) {
<span class="fc" id="L54">    int index = combination[parameters[0]];</span>
<span class="pc bpc" id="L55" title="1 of 2 branches missed.">    for (int i = 1; i &lt; parameters.length - 1; i++) {</span>
<span class="nc" id="L56">      int parameterIndex = parameters[i];</span>
<span class="nc" id="L57">      index = index * domainSizes[parameterIndex] + combination[parameterIndex];</span>
    }
<span class="fc" id="L59">    return index;</span>
  }



  /**
   * Converts a given value index to his corresonding value array representation.
   * 
   * @param domainSizes The sizes of the parameter domains.
   * @param index The value index to convert.
   * @param parameterCount The total amount of parameters.
   * @param parameters The parameters used in this value index.
   * @return An array of size parameterCount containing
   */
  public static int[] unpackValues(int[] domainSizes, int index, int parameterCount,
      int[] parameters) {
<span class="nc" id="L75">    int[] combination = new int[parameterCount];</span>
<span class="nc" id="L76">    fillWithParameterValues(domainSizes, index, parameters, combination);</span>
<span class="nc" id="L77">    return combination;</span>
  }



  public static void forEachParameterValue(int[] domainSizes, int index,
      int[] parameters, BiConsumer&lt;Integer, Integer&gt; consumer) {
<span class="nc bnc" id="L84" title="All 2 branches missed.">    for (int i = parameters.length - 1; i &gt;= 0; i--) {</span>
<span class="nc" id="L85">      int parameterIndex = parameters[i];</span>
<span class="nc" id="L86">      int paramDomainSize = domainSizes[parameterIndex];</span>
<span class="nc" id="L87">      int x = index % paramDomainSize;</span>
<span class="nc" id="L88">      consumer.accept(i, x);</span>
<span class="nc" id="L89">      index = (index - x) / paramDomainSize;</span>
    }
<span class="nc" id="L91">  }</span>



  /**
   * Fills the given test with values of the tupel defined by index and an ascending order of
   * parameters. Every other value is -1. This method is an easy way of calling:
   * 
   * &lt;pre&gt;
   * {@code #generateNewTest(domainsizes, index, new int[]{parameterOffset, ..., parameterOffset+parameterCount})}
   * &lt;/pre&gt;
   * 
   * @param domainSizes The sizes of the parameter domains.
   * @param index The index representation of the tupel.
   * @param parameterOffset The first parameter to fill
   * @param parameterCount The amount of parameters to fill
   */
  public static int[] generateNewTest(int[] domainSizes, int index, int parameterOffset,
      int parameterCount) {
<span class="fc" id="L110">    int[] test = new int[domainSizes.length];</span>
<span class="fc" id="L111">    Arrays.fill(test, -1);</span>
<span class="fc" id="L112">    fillWithParameterValues(domainSizes, index, parameterOffset, parameterCount, test);</span>
<span class="fc" id="L113">    return test;</span>
  }



  /**
   * Fills the given test with values of the tupel defined by index and an ascending order of
   * parameters. This method is an easy way of calling:
   * 
   * &lt;pre&gt;
   * {@code #fillWithParameterValues(domainsizes, index, new int[]{parameterOffset, ..., parameterOffset+parameterCount}, testToFill)}
   * &lt;/pre&gt;
   * 
   * @param domainSizes The sizes of the parameter domains.
   * @param index The index representation of the tupel.
   * @param parameterOffset The first parameter to fill
   * @param parameterCount The amount of parameters to fill
   * @param testToFill the test to fill.
   */
  public static void fillWithParameterValues(int[] domainSizes, int index, int parameterOffset,
      int parameterCount, int[] testToFill) {
<span class="fc bfc" id="L134" title="All 2 branches covered.">    for (int i = parameterCount - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L135">      int paramDomainSize = domainSizes[i + parameterOffset];</span>
<span class="fc" id="L136">      int x = index % paramDomainSize;</span>
<span class="fc" id="L137">      testToFill[parameterOffset + i] = x;</span>
<span class="fc" id="L138">      index = (index - x) / paramDomainSize;</span>
    }
<span class="fc" id="L140">  }</span>



  /**
   * Fills the given test with values of the tupel defined by index.
   * 
   * @param domainSizes The sizes of the parameter domains.
   * @param index The index representation of the tupel
   * @param paramComb The combination of parameters for the given value index
   * @param testToFill The test to fill in values.
   */
  public static void fillWithParameterValues(int[] domainSizes, int index, int[] paramComb,
      int[] testToFill) {
<span class="nc bnc" id="L154" title="All 2 branches missed.">    for (int i = paramComb.length - 1; i &gt;= 0; i--) {</span>
<span class="nc" id="L155">      int paramIndex = paramComb[i];</span>
<span class="nc" id="L156">      int paramDomainSize = domainSizes[paramIndex];</span>
<span class="nc" id="L157">      int x = index % paramDomainSize;</span>
<span class="nc" id="L158">      testToFill[paramIndex] = x;</span>
<span class="nc" id="L159">      index = (index - x) / paramDomainSize;</span>
    }
<span class="nc" id="L161">  }</span>



  /**
   * Creates a new test with the values of the tupel defined by index, and every other value being
   * -1
   * 
   * @param domainSizes The sizes of the parameter domains
   * @param index The index representation of the tupel.
   * @param paramComb The combination of parameters for the given value index
   * @return
   */
  public static int[] generateNewTest(int[] domainSizes, int index, int[] paramComb) {
<span class="nc" id="L175">    int[] test = new int[domainSizes.length];</span>
<span class="nc" id="L176">    Arrays.fill(test, -1);</span>
<span class="nc" id="L177">    fillWithParameterValues(domainSizes, index, paramComb, test);</span>
<span class="nc" id="L178">    return test;</span>
  }



  /**
   * Calculates the binomial coefficient n choose k.
   * 
   * @param n
   * @param k
   * @return
   */
  public static int binomCoeff(int n, int k) {
    int nFac, kFac, nmkFac;
<span class="fc" id="L192">    nmkFac = 1;</span>
<span class="pc bpc" id="L193" title="1 of 2 branches missed.">    for (int i = 2; i &lt;= n - k; i++) {</span>
<span class="nc" id="L194">      nmkFac *= i;</span>
    }
<span class="fc" id="L196">    int v = 1;</span>
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">    for (int i = 2; i &lt;= k; i++) {</span>
<span class="nc" id="L198">      v *= i;</span>
    }
<span class="fc" id="L200">    kFac = v;</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">    for (int i = k + 1; i &lt;= n; i++) {</span>
<span class="fc" id="L202">      v *= i;</span>
    }
<span class="fc" id="L204">    nFac = v;</span>

<span class="fc" id="L206">    return nFac / (kFac * nmkFac);</span>
  }
  
  /**
   * Returns the parameter combination with index 0 for iterating over every combination.
   * 
   * @param strength The strength of the combination aka the strength of the combinatorial test.
   * @return An int[] representing the parameter combination with index 0.
   */
  public static int[] getFirstParamComb(int strength) {
<span class="fc" id="L216">    int[] first = new int[strength];</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">    for (int i = 0; i &lt; first.length; i++) {</span>
<span class="fc" id="L218">      first[i] = i;</span>
    }
<span class="fc" id="L220">    return first;</span>
  }

  /**
   * Updates the given parameter combination with any index i to be the combination with index i+1.
   * Does not wrap around from the last index to index 0, but creates wrong combinations!
   * Only use it for combinations with index smaller than the biggest index.
   * 
   * @param currentComb The parameter combination to update to the next index.
   */
  public static void getNextParamComb(int[] currentComb) {
<span class="nc" id="L231">    int lastParam = currentComb[0];</span>
<span class="nc" id="L232">    int adjacentParamCount = 0;</span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">    for (int i = 1; i &lt; currentComb.length; i++) {</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">      if (currentComb[i] == lastParam + 1) {</span>
<span class="nc" id="L235">        lastParam = currentComb[i];</span>
<span class="nc" id="L236">        adjacentParamCount++;</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">        if(i==currentComb.length-1) {</span>
<span class="nc" id="L238">          currentComb[i]++;</span>
        }
<span class="nc" id="L240">      } else {</span>
<span class="nc" id="L241">        currentComb[i - 1] += 1;</span>
<span class="nc" id="L242">        break;</span>
      }
    }
<span class="nc bnc" id="L245" title="All 2 branches missed.">    for (int i = 0; i &lt; adjacentParamCount; i++) {</span>
<span class="nc" id="L246">      currentComb[i] = i;</span>
    }
<span class="nc" id="L248">  }</span>

  /**
   * Returns the parameter combination with index 0 for iterating over every combination where the
   * last parameter (parameterCount-1) is fix.
   * 
   * @param strength The strength of the combination aka the strength of the combinatorial test.
   * @param parameterCount The complete amount of parameters.
   * @return An int[] representing the parameter combination with index 0.
   */
  public static int[] getFirstParamCombWithFixParam(int strength, int parameterCount) {
<span class="fc" id="L259">    int[] first = getFirstParamComb(strength);</span>
<span class="fc" id="L260">    first[strength - 1] = parameterCount - 1;</span>
<span class="fc" id="L261">    return first;</span>
  }
  
  /**
   * Updates the given parameter combination with fix last parameter with any index i to be the combination with index i+1.
   * Does not wrap around from the last index to index 0, but creates wrong combinations!
   * Only use it for combinations with index smaller than the biggest index.
   * 
   * @param currentComb The parameter combination to update to the next index.
   */
  public static void getNextParamCombWithFixParam(int[] currentComb) {
<span class="fc" id="L272">    int lastParam = currentComb[0];</span>
<span class="fc" id="L273">    int adjacentParamCount = 0;</span>
<span class="fc bfc" id="L274" title="All 2 branches covered.">    for (int i = 1; i &lt; currentComb.length; i++) {</span>
<span class="fc bfc" id="L275" title="All 2 branches covered.">      if (currentComb[i] == lastParam + 1) {</span>
<span class="fc" id="L276">        lastParam = currentComb[i];</span>
<span class="fc" id="L277">        adjacentParamCount++;</span>
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">        if (i == currentComb.length - 2) {</span>
<span class="nc" id="L279">          currentComb[i] += 1;</span>
<span class="nc" id="L280">          break;</span>
        }
      } else {
<span class="fc" id="L283">        currentComb[i - 1] += 1;</span>
<span class="fc" id="L284">        break;</span>
      }
    }
<span class="fc bfc" id="L287" title="All 2 branches covered.">    for (int i = 0; i &lt; adjacentParamCount; i++) {</span>
<span class="fc" id="L288">      currentComb[i] = i;</span>
    }
<span class="fc" id="L290">  }</span>


  public static class ConvertedIterator&lt;A, B&gt; implements Iterator&lt;B&gt; {

    private Iterator&lt;A&gt; source;
    private Function&lt;A, B&gt; converter;



    public ConvertedIterator(Iterator&lt;A&gt; source, Function&lt;A, B&gt; converter) {
<span class="nc" id="L301">      super();</span>
<span class="nc" id="L302">      this.source = source;</span>
<span class="nc" id="L303">      this.converter = converter;</span>
<span class="nc" id="L304">    }</span>



    @Override
    public boolean hasNext() {
<span class="nc" id="L310">      return source.hasNext();</span>
    }



    @Override
    public B next() {
<span class="nc" id="L317">      return converter.apply(source.next());</span>
    }

  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span>HashMapTest.testAdd(int, float, boolean) (29.05.2019 13:02:31)</div></body></html>