<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="de"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../jacoco-resources/report.gif" type="image/gif"/><title>OrthogonalArrayGenerator.java</title><link rel="stylesheet" href="../../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=2;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">HashMapTest.testAdd(int, float, boolean) (29.05.2019 13:02:31)</a> &gt; <a href="../../index.html" class="el_group">CombTest</a> &gt; <a href="../index.html" class="el_bundle">src/main/java</a> &gt; <a href="index.source.html" class="el_package">jcomb.core.oa</a> &gt; <span class="el_source">OrthogonalArrayGenerator.java</span></div><h1>OrthogonalArrayGenerator.java</h1><pre class="source lang-java linenums">package jcomb.core.oa;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Stream;
import jcomb.core.Algorithm;
import jcomb.core.JCombContext;
import jcomb.core.JCombException;
import jcomb.core.TestInputGenerator;
import jcomb.core.oa.finitefield.FiniteField;
import jcomb.core.oa.finitefield.PrimeField;
import jcomb.core.oa.finitefield.SavedFiniteField;

/**
 * A {@link TestInputGenerator} that implements the algorithm Orthogonal Array.
 * 
 * @author Noah Zuch
 *
 */
<span class="nc bnc" id="L20" title="All 2 branches missed.">public class OrthogonalArrayGenerator implements TestInputGenerator {</span>

  private int parameterCount;
  private int valueCount;



  /**
   * Creates a new generator.
   * The supplied context has to follow the restrictions described in {@link Algorithm#OA}.
   * 
   * @param context the {@code JCombContext} to use.
   * @throws JCombException if the orthogonal array construction is not possible for the supplied
   * context.
   */
<span class="nc" id="L35">  public OrthogonalArrayGenerator(int parameterCount, int valueCount) {</span>
<span class="nc bnc" id="L36" title="All 4 branches missed.">    assert parameterCount &gt; 0;</span>

<span class="nc" id="L38">    this.parameterCount = parameterCount;</span>
<span class="nc" id="L39">    this.valueCount = valueCount;</span>

<span class="nc" id="L41">    checkInput(parameterCount, valueCount);</span>
<span class="nc" id="L42">  }</span>



  @Override
  public Stream&lt;int[]&gt; getAllInputCombinations() {
<span class="nc bnc" id="L48" title="All 4 branches missed.">    assert parameterCount &gt;= 2;</span>

<span class="nc bnc" id="L50" title="All 2 branches missed.">    if (parameterCount == 2) {</span>
<span class="nc" id="L51">      return getAllInputFor2Param();</span>
<span class="nc bnc" id="L52" title="All 2 branches missed.">    } else if (parameterCount == 3) {</span>
<span class="nc" id="L53">      return getAllInputFor3Param();</span>
    } else {
<span class="nc" id="L55">      return getAllInputForAnyParamTest();</span>
    }
  }



  private Stream&lt;int[]&gt; getAllInputFor2Param() {
<span class="nc bnc" id="L62" title="All 4 branches missed.">    assert parameterCount == 2;</span>

<span class="nc" id="L64">    List&lt;int[]&gt; result = new ArrayList&lt;&gt;(valueCount ^ 2);</span>
<span class="nc bnc" id="L65" title="All 2 branches missed.">    for (int iIndex = 0; iIndex &lt; valueCount; iIndex++) {</span>
<span class="nc bnc" id="L66" title="All 2 branches missed.">      for (int jIndex = 0; jIndex &lt; valueCount; jIndex++) {</span>
<span class="nc" id="L67">        int[] test = new int[parameterCount];</span>
<span class="nc" id="L68">        test[0] = iIndex;</span>
<span class="nc" id="L69">        test[1] = jIndex;</span>
<span class="nc" id="L70">        result.add(test);</span>
      }
    }

<span class="nc" id="L74">    return result.stream();</span>
  }



  private Stream&lt;int[]&gt; getAllInputFor3Param() {
<span class="nc bnc" id="L80" title="All 4 branches missed.">    assert parameterCount == 3;</span>

<span class="nc" id="L82">    List&lt;int[]&gt; result = new ArrayList&lt;&gt;(valueCount ^ 2);</span>
<span class="nc bnc" id="L83" title="All 2 branches missed.">    for (int iIndex = 0; iIndex &lt; valueCount; iIndex++) {</span>
<span class="nc bnc" id="L84" title="All 2 branches missed.">      for (int jIndex = 0; jIndex &lt; valueCount; jIndex++) {</span>
<span class="nc" id="L85">        int[] test = new int[parameterCount];</span>
<span class="nc" id="L86">        test[0] = iIndex;</span>
<span class="nc" id="L87">        test[1] = jIndex;</span>
<span class="nc" id="L88">        test[2] = (iIndex + jIndex) % valueCount;</span>
<span class="nc" id="L89">        result.add(test);</span>
      }
    }

<span class="nc" id="L93">    return result.stream();</span>
  }



  private Stream&lt;int[]&gt; getAllInputForAnyParamTest() {
<span class="nc" id="L99">    List&lt;FiniteField&gt; fFields = Tools.getFiniteFieldsViaPrimeFactors(valueCount);</span>
<span class="nc" id="L100">    int arraySize = (int) Math.pow(valueCount, 2);</span>
<span class="nc" id="L101">    List&lt;int[]&gt; result = new ArrayList&lt;&gt;(arraySize);</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">    for (int i = 0; i &lt; arraySize; i++) {</span>
<span class="nc" id="L103">      result.add(new int[parameterCount]);</span>
    }
<span class="nc" id="L105">    fillOrthogonalArray(result, fFields, 0, new int[parameterCount], 0);</span>

<span class="nc" id="L107">    return result.stream();</span>
  }



  private int fillOrthogonalArray(List&lt;int[]&gt; orthogonalArray, List&lt;FiniteField&gt; fFields,
      int fieldIndex, int[] valueOffsets, int testIndex) {
<span class="nc" id="L114">    FiniteField field = fFields.get(fieldIndex);</span>
<span class="nc bnc" id="L115" title="All 2 branches missed.">    for (int iIndex = 0; iIndex &lt; field.size(); iIndex++) {</span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">      for (int jIndex = 0; jIndex &lt; field.size(); jIndex++) {</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">        if (fieldIndex == fFields.size() - 1) {</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">          for (int k = 0; k &lt; parameterCount; k++) {</span>
<span class="nc" id="L119">            orthogonalArray.get(testIndex)[k] =</span>
<span class="nc" id="L120">                computeValue(field, k, iIndex, jIndex) + valueOffsets[k];</span>
          }
<span class="nc" id="L122">          testIndex++;</span>
<span class="nc" id="L123">        } else {</span>
<span class="nc" id="L124">          int[] newValueOffsets = new int[parameterCount];</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">          for (int k = 0; k &lt; parameterCount; k++) {</span>
<span class="nc" id="L126">            newValueOffsets[k] = fFields.get(fieldIndex + 1).size()</span>
<span class="nc" id="L127">                * (valueOffsets[k] + computeValue(field, k, iIndex, jIndex));</span>
          }
<span class="nc" id="L129">          testIndex = fillOrthogonalArray(orthogonalArray, fFields, fieldIndex + 1, newValueOffsets,</span>
<span class="nc" id="L130">              testIndex);</span>
        }
      }
    }
<span class="nc" id="L134">    return testIndex;</span>
  }



  private int computeValue(FiniteField field, int parameter, int iIndex, int jIndex) {
<span class="nc bnc" id="L140" title="All 2 branches missed.">    if (parameter == 0) {</span>
<span class="nc" id="L141">      return iIndex;</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">    } else if (parameter == 1) {</span>
<span class="nc" id="L143">      return jIndex;</span>
    } else {
<span class="nc" id="L145">      return field.add(jIndex, field.multiply(parameter - 1, iIndex));</span>
    }
  }



  private void checkInput(int k, int v) {
<span class="nc bnc" id="L152" title="All 2 branches missed.">    if (k &lt; 2) {</span>
<span class="nc" id="L153">      throw new IllegalArgumentException(</span>
<span class="nc" id="L154">          &quot;Algorithm Orhtogonal Array needs at least two parameter.&quot;);</span>
    }

<span class="nc bnc" id="L157" title="All 2 branches missed.">    if (k &gt; 3) {</span>
<span class="nc bnc" id="L158" title="All 2 branches missed.">      if (k &gt; v + 1) {</span>
<span class="nc" id="L159">        throw new IllegalArgumentException(</span>
<span class="nc" id="L160">            &quot;The algorithm Orthogonal Array can not work with the number of parameters being higher than the number of parametervalues plus one&quot;);</span>
      }
    }
    // if (v &lt; 2) {
    // throw new JCombException(
    // &quot;The algorithm Orthogonal Array needs at least two values for each parameter&quot;);
    // }
<span class="nc" id="L167">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span>HashMapTest.testAdd(int, float, boolean) (29.05.2019 13:02:31)</div></body></html>