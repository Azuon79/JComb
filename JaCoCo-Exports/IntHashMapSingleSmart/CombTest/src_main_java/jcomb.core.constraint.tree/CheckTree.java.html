<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="de"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../jacoco-resources/report.gif" type="image/gif"/><title>CheckTree.java</title><link rel="stylesheet" href="../../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=2;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">HashMapTest.testSingleAdd (29.05.2019 13:08:27)</a> &gt; <a href="../../index.html" class="el_group">CombTest</a> &gt; <a href="../index.html" class="el_bundle">src/main/java</a> &gt; <a href="index.source.html" class="el_package">jcomb.core.constraint.tree</a> &gt; <span class="el_source">CheckTree.java</span></div><h1>CheckTree.java</h1><pre class="source lang-java linenums">package jcomb.core.constraint.tree;

import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.stream.Collectors;
import jcomb.core.JCombContext;
import jcomb.core.constraint.Constraint;
import jcomb.core.constraint.ConstraintHandler;
import jcomb.core.parameter.Domain;

public class CheckTree implements ConstraintHandler {

  private CheckNode root;
<span class="nc" id="L15">  private static final CheckNode falseLeave = new LeaveNode(false);</span>



<span class="nc" id="L19">  public CheckTree(JCombContext jCombContext) {</span>
<span class="nc" id="L20">    List&lt;Constraint&gt; constraints = jCombContext.getConstraints().values().stream().sorted((l1, l2) -&gt; Integer.compare(l1.getInvolvedParameters().length,</span>
<span class="nc" id="L21">          l2.getInvolvedParameters().length)).collect(Collectors.toList());</span>
<span class="nc bnc" id="L22" title="All 2 branches missed.">    if (constraints.size() == 0) {</span>
<span class="nc" id="L23">      root = null;</span>
<span class="nc" id="L24">    } else {</span>
<span class="nc" id="L25">      root = createNode(jCombContext, new Object[jCombContext.getParameterCount()], 0,</span>
<span class="nc" id="L26">          new boolean[jCombContext.getParameterCount()], 0, constraints);</span>
    }
<span class="nc" id="L28">  }</span>



  @Override
  public boolean isSatisfiable(int[] combination) {
    // null represents true, but decreases tree size
<span class="nc bnc" id="L35" title="All 4 branches missed.">    return root == null || root.isSatisfiable(combination);</span>
  }



  private CheckNode createNode(JCombContext context, Object[] combination, int currentConstraintParameter,
      boolean[] coveredParameters, int currentConstraint,
      List&lt;Constraint&gt; constraintIt) {
<span class="nc" id="L43">    int currentParameter = constraintIt.get(currentConstraint).getInvolvedParameters()[currentConstraintParameter];</span>
    // check whether or not this is the last parameter for the current constraint
<span class="nc bnc" id="L45" title="All 2 branches missed.">    if (currentConstraintParameter == constraintIt.get(currentConstraint).getInvolvedParameters().length</span>
<span class="nc" id="L46">        - 1) {</span>
<span class="nc bnc" id="L47" title="All 2 branches missed.">      if (!coveredParameters[currentParameter]) {</span>
        // if the last parameter is not yet covered, cover it and at the same time check for the
        // constraint
<span class="nc" id="L50">        coveredParameters[currentParameter] = true;</span>
<span class="nc" id="L51">        CheckNode node =</span>
<span class="nc" id="L52">            createConstraintEndNode(context, combination, currentConstraintParameter, coveredParameters,</span>
<span class="nc" id="L53">                currentConstraint,</span>
<span class="nc" id="L54">                constraintIt);</span>
<span class="nc" id="L55">        coveredParameters[currentParameter] = false;</span>
<span class="nc" id="L56">        return node;</span>
      } else {
        // if the last parameter is already covered, only check for the constraint
<span class="nc" id="L59">        return checkConstraintEndNode(context, combination, currentConstraintParameter, coveredParameters,</span>
<span class="nc" id="L60">            currentConstraint,</span>
<span class="nc" id="L61">            constraintIt);</span>
      }
    } else {
<span class="nc bnc" id="L64" title="All 2 branches missed.">      if (!coveredParameters[currentParameter]) {</span>
        // if the current parameter is not yet covered, cover it
<span class="nc" id="L66">        coveredParameters[currentParameter] = true;</span>
<span class="nc" id="L67">        CheckNode node =</span>
<span class="nc" id="L68">            createCompleteInnerNode(context, combination, currentConstraintParameter, coveredParameters,</span>
<span class="nc" id="L69">                currentConstraint, constraintIt);</span>
<span class="nc" id="L70">        coveredParameters[currentParameter]=false;</span>
<span class="nc" id="L71">        return node;</span>
      } else {
        // if the current parameter is already covered, go on with the next parameter
<span class="nc" id="L74">        return createNode(context, combination, currentConstraintParameter + 1, coveredParameters,</span>
<span class="nc" id="L75">            currentConstraint,</span>
<span class="nc" id="L76">            constraintIt);</span>
      }
    }
  }



  private CheckNode checkConstraintEndNode(JCombContext context, Object[] combination,
      int currentConstraintParameter,
      boolean[] coveredParameters, int currentConstraint,
      List&lt;Constraint&gt; constraintIt) {
<span class="nc" id="L87">    Constraint constraint = constraintIt.get(currentConstraint);</span>


<span class="nc bnc" id="L90" title="All 2 branches missed.">    if (!checkConstraintWithFullCombination(constraint, combination)) {</span>
      // Constraint not fulfilled
<span class="nc" id="L92">      return falseLeave;</span>
    } else {
      // Constraint fulfilled
<span class="nc bnc" id="L95" title="All 2 branches missed.">      if (currentConstraint &lt; constraintIt.size() - 1) {</span>
<span class="nc" id="L96">        return createNode(context, combination, 0, coveredParameters, currentConstraint + 1,</span>
<span class="nc" id="L97">            constraintIt);</span>
      } else {
<span class="nc" id="L99">        return null; // null represents true, but decreases tree size</span>
      }
    }
  }



  private CheckNode createConstraintEndNode(JCombContext context, Object[] combination,
      int currentConstraintParameter,
      boolean[] coveredParameters, int currentConstraint,
      List&lt;Constraint&gt; constraintIt) {
<span class="nc" id="L110">    Constraint constraint = constraintIt.get(currentConstraint);</span>
<span class="nc" id="L111">    int currentParameter = constraint.getInvolvedParameters()[currentConstraintParameter];</span>
<span class="nc" id="L112">    Domain parameter = context.getParameter(currentParameter);</span>
<span class="nc" id="L113">    InnerNode newNode = null;</span>

<span class="nc bnc" id="L115" title="All 2 branches missed.">    for (int valueIndex = 0; valueIndex &lt; parameter.getSize(); valueIndex++) {</span>
<span class="nc" id="L116">      combination[currentParameter] = parameter.getValueAt(valueIndex);</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">      if (!checkConstraintWithFullCombination(constraint, combination)) {</span>
        // Constraint not fulfilled
<span class="nc bnc" id="L119" title="All 2 branches missed.">        if (newNode == null) {</span>
<span class="nc" id="L120">          newNode = new InnerNode(currentParameter, parameter.getSize());</span>
        }
<span class="nc" id="L122">        newNode.setChild(valueIndex, falseLeave);</span>
<span class="nc" id="L123">      } else {</span>
        // Constraint fulfilled
        CheckNode child;
<span class="nc bnc" id="L126" title="All 2 branches missed.">        if (currentConstraint &lt; constraintIt.size() - 1) {</span>
<span class="nc" id="L127">          child =</span>
<span class="nc" id="L128">              createNode(context, combination, 0, coveredParameters, currentConstraint + 1,</span>
<span class="nc" id="L129">                  constraintIt);</span>
<span class="nc" id="L130">        } else {</span>
<span class="nc" id="L131">          child = null; // null represents true, but decreases tree size</span>
        }
<span class="nc bnc" id="L133" title="All 2 branches missed.">        if (child != null) {</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">          if (newNode == null) {</span>
<span class="nc" id="L135">            newNode = new InnerNode(currentParameter, parameter.getSize());</span>
          }
<span class="nc" id="L137">          newNode.setChild(valueIndex, child);</span>
        }
      }
    }
<span class="nc" id="L141">    return newNode;</span>
  }



  private CheckNode createCompleteInnerNode(JCombContext context, Object[] combination,
      int currentConstraintParameter,
      boolean[] coveredParameters, int currentConstraint,
      List&lt;Constraint&gt; constraintIt) {
<span class="nc" id="L150">    Constraint constraint = constraintIt.get(currentConstraint);</span>
<span class="nc" id="L151">    int currentParameter = constraint.getInvolvedParameters()[currentConstraintParameter];</span>
<span class="nc" id="L152">    InnerNode newNode = null;</span>
<span class="nc" id="L153">    Domain parameter = context.getParameter(currentParameter);</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">    for (int valueIndex = 0; valueIndex &lt; parameter.getSize(); valueIndex++) {</span>
<span class="nc" id="L155">      combination[currentParameter] = parameter.getValueAt(valueIndex);</span>
<span class="nc" id="L156">      CheckNode child =</span>
<span class="nc" id="L157">          createNode(context, combination, currentConstraintParameter + 1, coveredParameters,</span>
<span class="nc" id="L158">              currentConstraint,</span>
<span class="nc" id="L159">              constraintIt);</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">      if (child != null) {</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">        if (newNode == null) {</span>
<span class="nc" id="L162">          newNode = new InnerNode(currentParameter, parameter.getSize());</span>
        }
<span class="nc" id="L164">        newNode.setChild(valueIndex, child);</span>
      }
    }
<span class="nc" id="L167">    return newNode;</span>
  }



  public boolean checkConstraintWithFullCombination(Constraint con, Object[] combination) {
<span class="nc" id="L173">    Object[] input = new Object[con.getInvolvedParameters().length];</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">    for (int i = 0; i &lt; con.getInvolvedParameters().length; i++) {</span>
<span class="nc" id="L175">      input[i] = combination[con.getInvolvedParameters()[i]];</span>
    }
<span class="nc" id="L177">    return con.confirmsWith(input);</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span>HashMapTest.testSingleAdd (29.05.2019 13:08:27)</div></body></html>