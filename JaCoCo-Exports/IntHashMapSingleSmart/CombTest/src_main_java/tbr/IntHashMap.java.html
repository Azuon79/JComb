<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="de"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../jacoco-resources/report.gif" type="image/gif"/><title>IntHashMap.java</title><link rel="stylesheet" href="../../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=2;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">HashMapTest.testSingleAdd (29.05.2019 13:08:27)</a> &gt; <a href="../../index.html" class="el_group">CombTest</a> &gt; <a href="../index.html" class="el_bundle">src/main/java</a> &gt; <a href="index.source.html" class="el_package">tbr</a> &gt; <span class="el_source">IntHashMap.java</span></div><h1>IntHashMap.java</h1><pre class="source lang-java linenums">package tbr;


import java.io.IOException;
import java.io.Serializable;
import java.util.AbstractCollection;
import java.util.AbstractSet;
import java.util.Collection;
import java.util.ConcurrentModificationException;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Set;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * This is an integer hashmap that has the exact same features and interface as a normal Map except
 * that the key is directly an integer. So no hash is calculated or key object is stored.
 * 
 * @author jcompagner
 * 
 * @param &lt;V&gt;
 *            The value in the map
 */
public class IntHashMap&lt;V&gt; implements Cloneable, Serializable
{
<span class="pc" id="L26">    transient volatile Set&lt;Integer&gt; keySet = null;</span>

<span class="pc" id="L28">    transient volatile Collection&lt;V&gt; values = null;</span>

    /**
     * The default initial capacity - MUST be a power of two.
     */
    static final int DEFAULT_INITIAL_CAPACITY = 16;

    /**
     * The maximum capacity, used if a higher value is implicitly specified by either of the
     * constructors with arguments. MUST be a power of two &lt;= 1&lt;&lt;30.
     */
    static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;

    /**
     * The load factor used when none specified in constructor.
     */
    static final float DEFAULT_LOAD_FACTOR = 0.75f;

    /**
     * The table, resized as necessary. Length MUST Always be a power of two.
     */
    transient Entry&lt;V&gt;[] table;

    /**
     * The number of key-value mappings contained in this identity hash map.
     */
    transient int size;

    /**
     * The next size value at which to resize (capacity * load factor).
     * 
     * @serial
     */
    int threshold;

    /**
     * The load factor for the hash table.
     * 
     * @serial
     */
    final float loadFactor;

    /**
     * The number of times this HashMap has been structurally modified Structural modifications are
     * those that change the number of mappings in the HashMap or otherwise modify its internal
     * structure (e.g., rehash). This field is used to make iterators on Collection-views of the
     * HashMap fail-fast. (See ConcurrentModificationException).
     */
<span class="pc" id="L76">    transient AtomicInteger modCount = new AtomicInteger(0);</span>

    /**
     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial capacity and load factor.
     * 
     * @param initialCapacity
     *            The initial capacity.
     * @param loadFactor
     *            The load factor.
     * @throws IllegalArgumentException
     *             if the initial capacity is negative or the load factor is nonpositive.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L89">    public IntHashMap(int initialCapacity, final float loadFactor)</span>
    {
<span class="pc bpc" id="L91" title="1 of 2 branches missed.">        if (initialCapacity &lt; 0)</span>
        {
<span class="nc" id="L93">            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + //$NON-NLS-1$</span>
<span class="nc" id="L94">                initialCapacity);</span>
        }
<span class="pc bpc" id="L96" title="1 of 2 branches missed.">        if (initialCapacity &gt; MAXIMUM_CAPACITY)</span>
        {
<span class="nc" id="L98">            initialCapacity = MAXIMUM_CAPACITY;</span>
        }
<span class="pc bpc" id="L100" title="2 of 4 branches missed.">        if ((loadFactor &lt;= 0) || Float.isNaN(loadFactor))</span>
        {
<span class="nc" id="L102">            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + //$NON-NLS-1$</span>
<span class="nc" id="L103">                loadFactor);</span>
        }

        // Find a power of 2 &gt;= initialCapacity
<span class="fc" id="L107">        int capacity = 1;</span>
<span class="fc bfc" id="L108" title="All 2 branches covered.">        while (capacity &lt; initialCapacity)</span>
        {
<span class="fc" id="L110">            capacity &lt;&lt;= 1;</span>
        }

<span class="fc" id="L113">        this.loadFactor = loadFactor;</span>
<span class="fc" id="L114">        threshold = (int)(capacity * loadFactor);</span>
<span class="fc" id="L115">        table = new Entry[capacity];</span>
<span class="fc" id="L116">        init();</span>
<span class="fc" id="L117">    }</span>

    /**
     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial capacity and the default load
     * factor (0.75).
     * 
     * @param initialCapacity
     *            the initial capacity.
     * @throws IllegalArgumentException
     *             if the initial capacity is negative.
     */
    public IntHashMap(final int initialCapacity)
    {
<span class="nc" id="L130">        this(initialCapacity, DEFAULT_LOAD_FACTOR);</span>
<span class="nc" id="L131">    }</span>

    /**
     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity (16) and the default
     * load factor (0.75).
     */
    @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L138">    public IntHashMap()</span>
    {
<span class="nc" id="L140">        loadFactor = DEFAULT_LOAD_FACTOR;</span>
<span class="nc" id="L141">        threshold = (int)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR);</span>
<span class="nc" id="L142">        table = new Entry[DEFAULT_INITIAL_CAPACITY];</span>
<span class="nc" id="L143">        init();</span>
<span class="nc" id="L144">    }</span>

    // internal utilities

    /**
     * Initialization hook for subclasses. This method is called in all constructors and
     * pseudo-constructors (clone, readObject) after HashMap has been initialized but before any
     * entries have been inserted. (In the absence of this method, readObject would require explicit
     * knowledge of subclasses.)
     */
    void init()
    {
<span class="fc" id="L156">    }</span>

    /**
     * Returns index for hash code h.
     * 
     * @param h
     * @param length
     * @return The index for the hash integer for the given length
     */
    static int indexFor(final int h, final int length)
    {
<span class="fc" id="L167">        return h &amp; (length - 1);</span>
    }

    /**
     * Returns the number of key-value mappings in this map.
     * 
     * @return the number of key-value mappings in this map.
     */
    public int size()
    {
<span class="fc" id="L177">        return size;</span>
    }

    /**
     * Returns &lt;tt&gt;true&lt;/tt&gt; if this map contains no key-value mappings.
     * 
     * @return &lt;tt&gt;true&lt;/tt&gt; if this map contains no key-value mappings.
     */
    public boolean isEmpty()
    {
<span class="nc bnc" id="L187" title="All 2 branches missed.">        return size == 0;</span>
    }

    /**
     * Returns the value to which the specified key is mapped in this identity hash map, or
     * &lt;tt&gt;null&lt;/tt&gt; if the map contains no mapping for this key. A return value of &lt;tt&gt;null&lt;/tt&gt;
     * does not &lt;i&gt;necessarily&lt;/i&gt; indicate that the map contains no mapping for the key; it is also
     * possible that the map explicitly maps the key to &lt;tt&gt;null&lt;/tt&gt;. The &lt;tt&gt;containsKey&lt;/tt&gt;
     * method may be used to distinguish these two cases.
     * 
     * @param key
     *            the key whose associated value is to be returned.
     * @return the value to which this map maps the specified key, or &lt;tt&gt;null&lt;/tt&gt; if the map
     *         contains no mapping for this key.
     * @see #put(int, Object)
     */
    public V get(final int key)
    {
<span class="fc" id="L205">        int i = indexFor(key, table.length);</span>
<span class="fc" id="L206">        Entry&lt;V&gt; e = table[i];</span>
<span class="nc" id="L207">        while (true)</span>
        {
<span class="pc bpc" id="L209" title="1 of 2 branches missed.">            if (e == null)</span>
            {
<span class="nc" id="L211">                return null;</span>
            }
<span class="pc bpc" id="L213" title="1 of 2 branches missed.">            if (key == e.key)</span>
            {
<span class="fc" id="L215">                return e.value;</span>
            }
<span class="nc" id="L217">            e = e.next;</span>
        }
    }

    /**
     * Returns &lt;tt&gt;true&lt;/tt&gt; if this map contains a mapping for the specified key.
     * 
     * @param key
     *            The key whose presence in this map is to be tested
     * @return &lt;tt&gt;true&lt;/tt&gt; if this map contains a mapping for the specified key.
     */
    public boolean containsKey(final int key)
    {
<span class="nc" id="L230">        int i = indexFor(key, table.length);</span>
<span class="nc" id="L231">        Entry&lt;V&gt; e = table[i];</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">        while (e != null)</span>
        {
<span class="nc bnc" id="L234" title="All 2 branches missed.">            if (key == e.key)</span>
            {
<span class="nc" id="L236">                return true;</span>
            }
<span class="nc" id="L238">            e = e.next;</span>
        }
<span class="nc" id="L240">        return false;</span>
    }

    /**
     * Returns the entry associated with the specified key in the HashMap. Returns null if the
     * HashMap contains no mapping for this key.
     * 
     * @param key
     * @return The Entry object for the given hash key
     */
    Entry&lt;V&gt; getEntry(final int key)
    {
<span class="nc" id="L252">        int i = indexFor(key, table.length);</span>
<span class="nc" id="L253">        Entry&lt;V&gt; e = table[i];</span>
<span class="nc bnc" id="L254" title="All 4 branches missed.">        while ((e != null) &amp;&amp; !(key == e.key))</span>
        {
<span class="nc" id="L256">            e = e.next;</span>
        }
<span class="nc" id="L258">        return e;</span>
    }

    /**
     * Associates the specified value with the specified key in this map. If the map previously
     * contained a mapping for this key, the old value is replaced.
     * 
     * @param key
     *            key with which the specified value is to be associated.
     * @param value
     *            value to be associated with the specified key.
     * @return previous value associated with specified key, or &lt;tt&gt;null&lt;/tt&gt; if there was no
     *         mapping for key. A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the HashMap previously
     *         associated &lt;tt&gt;null&lt;/tt&gt; with the specified key.
     */
    public V put(final int key, final V value)
    {
<span class="fc" id="L275">        int i = indexFor(key, table.length);</span>

<span class="pc bpc" id="L277" title="1 of 2 branches missed.">        for (Entry&lt;V&gt; e = table[i]; e != null; e = e.next)</span>
        {
<span class="nc bnc" id="L279" title="All 2 branches missed.">            if (key == e.key)</span>
            {
<span class="nc" id="L281">                V oldValue = e.value;</span>
<span class="nc" id="L282">                e.value = value;</span>
<span class="nc" id="L283">                return oldValue;</span>
            }
        }

<span class="fc" id="L287">        modCount.incrementAndGet();</span>
<span class="fc" id="L288">        addEntry(key, value, i);</span>
<span class="fc" id="L289">        return null;</span>
    }

    /**
     * This method is used instead of put by constructors and pseudoconstructors (clone,
     * readObject). It does not resize the table, check for comodification, etc. It calls
     * createEntry rather than addEntry.
     * 
     * @param key
     * @param value
     */
    private void putForCreate(final int key, final V value)
    {
<span class="nc" id="L302">        int i = indexFor(key, table.length);</span>

        /**
         * Look for preexisting entry for key. This will never happen for clone or deserialize. It
         * will only happen for construction if the input Map is a sorted map whose ordering is
         * inconsistent w/ equals.
         */
<span class="nc bnc" id="L309" title="All 2 branches missed.">        for (Entry&lt;V&gt; e = table[i]; e != null; e = e.next)</span>
        {
<span class="nc bnc" id="L311" title="All 2 branches missed.">            if (key == e.key)</span>
            {
<span class="nc" id="L313">                e.value = value;</span>
<span class="nc" id="L314">                return;</span>
            }
        }

<span class="nc" id="L318">        createEntry(key, value, i);</span>
<span class="nc" id="L319">    }</span>

    void putAllForCreate(final IntHashMap&lt;V&gt; m)
    {
<span class="nc bnc" id="L323" title="All 2 branches missed.">        for (Entry&lt;V&gt; entry : m.entrySet())</span>
        {
<span class="nc" id="L325">            putForCreate(entry.getKey(), entry.getValue());</span>
        }
<span class="nc" id="L327">    }</span>

    /**
     * Rehashes the contents of this map into a new array with a larger capacity. This method is
     * called automatically when the number of keys in this map reaches its threshold.
     * 
     * If current capacity is MAXIMUM_CAPACITY, this method does not resize the map, but but sets
     * threshold to Integer.MAX_VALUE. This has the effect of preventing future calls.
     * 
     * @param newCapacity
     *            the new capacity, MUST be a power of two; must be greater than current capacity
     *            unless current capacity is MAXIMUM_CAPACITY (in which case value is irrelevant).
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    void resize(final int newCapacity)
    {
<span class="fc" id="L343">        Entry&lt;V&gt;[] oldTable = table;</span>
<span class="fc" id="L344">        int oldCapacity = oldTable.length;</span>
<span class="pc bpc" id="L345" title="1 of 2 branches missed.">        if (oldCapacity == MAXIMUM_CAPACITY)</span>
        {
<span class="nc" id="L347">            threshold = Integer.MAX_VALUE;</span>
<span class="nc" id="L348">            return;</span>
        }

<span class="fc" id="L351">        Entry&lt;V&gt;[] newTable = new Entry[newCapacity];</span>
<span class="fc" id="L352">        transfer(newTable);</span>
<span class="fc" id="L353">        table = newTable;</span>
<span class="fc" id="L354">        threshold = (int)(newCapacity * loadFactor);</span>
<span class="fc" id="L355">    }</span>

    /**
     * Transfer all entries from current table to newTable.
     * 
     * @param newTable
     */
    void transfer(final Entry&lt;V&gt;[] newTable)
    {
<span class="fc" id="L364">        Entry&lt;V&gt;[] src = table;</span>
<span class="fc" id="L365">        int newCapacity = newTable.length;</span>
<span class="fc bfc" id="L366" title="All 2 branches covered.">        for (int j = 0; j &lt; src.length; j++)</span>
        {
<span class="fc" id="L368">            Entry&lt;V&gt; e = src[j];</span>
<span class="fc bfc" id="L369" title="All 2 branches covered.">            if (e != null)</span>
            {
<span class="fc" id="L371">                src[j] = null;</span>
                do
                {
<span class="fc" id="L374">                    Entry&lt;V&gt; next = e.next;</span>
<span class="fc" id="L375">                    int i = indexFor(e.key, newCapacity);</span>
<span class="fc" id="L376">                    e.next = newTable[i];</span>
<span class="fc" id="L377">                    newTable[i] = e;</span>
<span class="fc" id="L378">                    e = next;</span>
                }
<span class="pc bpc" id="L380" title="1 of 2 branches missed.">                while (e != null);</span>
            }
        }
<span class="fc" id="L383">    }</span>

    /**
     * Copies all of the mappings from the specified map to this map These mappings will replace any
     * mappings that this map had for any of the keys currently in the specified map.
     * 
     * @param m
     *            mappings to be stored in this map.
     * @throws NullPointerException
     *             if the specified map is null.
     */
    public void putAll(final IntHashMap&lt;V&gt; m)
    {
<span class="nc" id="L396">        int numKeysToBeAdded = m.size();</span>
<span class="nc bnc" id="L397" title="All 2 branches missed.">        if (numKeysToBeAdded == 0)</span>
        {
<span class="nc" id="L399">            return;</span>
        }

        /*
         * Expand the map if the map if the number of mappings to be added is greater than or equal
         * to threshold. This is conservative; the obvious condition is (m.size() + size) &gt;=
         * threshold, but this condition could result in a map with twice the appropriate capacity,
         * if the keys to be added overlap with the keys already in this map. By using the
         * conservative calculation, we subject ourself to at most one extra resize.
         */
<span class="nc bnc" id="L409" title="All 2 branches missed.">        if (numKeysToBeAdded &gt; threshold)</span>
        {
<span class="nc" id="L411">            int targetCapacity = (int)(numKeysToBeAdded / loadFactor + 1);</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">            if (targetCapacity &gt; MAXIMUM_CAPACITY)</span>
            {
<span class="nc" id="L414">                targetCapacity = MAXIMUM_CAPACITY;</span>
            }
<span class="nc" id="L416">            int newCapacity = table.length;</span>
<span class="nc bnc" id="L417" title="All 2 branches missed.">            while (newCapacity &lt; targetCapacity)</span>
            {
<span class="nc" id="L419">                newCapacity &lt;&lt;= 1;</span>
            }
<span class="nc bnc" id="L421" title="All 2 branches missed.">            if (newCapacity &gt; table.length)</span>
            {
<span class="nc" id="L423">                resize(newCapacity);</span>
            }
        }

<span class="nc bnc" id="L427" title="All 2 branches missed.">        for (Entry&lt;V&gt; entry : m.entrySet())</span>
        {
<span class="nc" id="L429">            put(entry.getKey(), entry.getValue());</span>
        }
<span class="nc" id="L431">    }</span>

    /**
     * Removes the mapping for this key from this map if present.
     * 
     * @param key
     *            key whose mapping is to be removed from the map.
     * @return previous value associated with specified key, or &lt;tt&gt;null&lt;/tt&gt; if there was no
     *         mapping for key. A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map previously
     *         associated &lt;tt&gt;null&lt;/tt&gt; with the specified key.
     */
    public V remove(final int key)
    {
<span class="nc" id="L444">        Entry&lt;V&gt; e = removeEntryForKey(key);</span>
<span class="nc bnc" id="L445" title="All 2 branches missed.">        return (e == null ? null : e.value);</span>
    }

    /**
     * Removes and returns the entry associated with the specified key in the HashMap. Returns null
     * if the HashMap contains no mapping for this key.
     * 
     * @param key
     * @return The Entry object that was removed
     */
    Entry&lt;V&gt; removeEntryForKey(final int key)
    {
<span class="nc" id="L457">        int i = indexFor(key, table.length);</span>
<span class="nc" id="L458">        Entry&lt;V&gt; prev = table[i];</span>
<span class="nc" id="L459">        Entry&lt;V&gt; e = prev;</span>

<span class="nc bnc" id="L461" title="All 2 branches missed.">        while (e != null)</span>
        {
<span class="nc" id="L463">            Entry&lt;V&gt; next = e.next;</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">            if (key == e.key)</span>
            {
<span class="nc" id="L466">                modCount.incrementAndGet();</span>
<span class="nc" id="L467">                size--;</span>
<span class="nc bnc" id="L468" title="All 2 branches missed.">                if (prev == e)</span>
                {
<span class="nc" id="L470">                    table[i] = next;</span>
<span class="nc" id="L471">                }</span>
                else
                {
<span class="nc" id="L474">                    prev.next = next;</span>
                }
<span class="nc" id="L476">                return e;</span>
            }
<span class="nc" id="L478">            prev = e;</span>
<span class="nc" id="L479">            e = next;</span>
        }

<span class="nc" id="L482">        return e;</span>
    }

    /**
     * Special version of remove for EntrySet.
     * 
     * @param o
     * @return The entry that was removed
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    Entry&lt;V&gt; removeMapping(final Object o)
    {
<span class="nc bnc" id="L494" title="All 2 branches missed.">        if (!(o instanceof Entry))</span>
        {
<span class="nc" id="L496">            return null;</span>
        }

<span class="nc" id="L499">        Entry&lt;V&gt; entry = (Entry&lt;V&gt;)o;</span>
<span class="nc" id="L500">        int key = entry.getKey();</span>
<span class="nc" id="L501">        int i = indexFor(key, table.length);</span>
<span class="nc" id="L502">        Entry&lt;V&gt; prev = table[i];</span>
<span class="nc" id="L503">        Entry&lt;V&gt; e = prev;</span>

<span class="nc bnc" id="L505" title="All 2 branches missed.">        while (e != null)</span>
        {
<span class="nc" id="L507">            Entry&lt;V&gt; next = e.next;</span>
<span class="nc bnc" id="L508" title="All 4 branches missed.">            if ((e.key == key) &amp;&amp; e.equals(entry))</span>
            {
<span class="nc" id="L510">                modCount.incrementAndGet();</span>
<span class="nc" id="L511">                size--;</span>
<span class="nc bnc" id="L512" title="All 2 branches missed.">                if (prev == e)</span>
                {
<span class="nc" id="L514">                    table[i] = next;</span>
<span class="nc" id="L515">                }</span>
                else
                {
<span class="nc" id="L518">                    prev.next = next;</span>
                }
<span class="nc" id="L520">                return e;</span>
            }
<span class="nc" id="L522">            prev = e;</span>
<span class="nc" id="L523">            e = next;</span>
        }

<span class="nc" id="L526">        return e;</span>
    }

    /**
     * Removes all mappings from this map.
     */
    public void clear()
    {
<span class="nc" id="L534">        modCount.incrementAndGet();</span>
<span class="nc" id="L535">        Entry&lt;V&gt; tab[] = table;</span>
<span class="nc bnc" id="L536" title="All 2 branches missed.">        for (int i = 0; i &lt; tab.length; i++)</span>
        {
<span class="nc" id="L538">            tab[i] = null;</span>
        }
<span class="nc" id="L540">        size = 0;</span>
<span class="nc" id="L541">    }</span>

    /**
     * Returns &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the specified value.
     * 
     * @param value
     *            value whose presence in this map is to be tested.
     * @return &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the specified value.
     */
    public boolean containsValue(final Object value)
    {
<span class="nc bnc" id="L552" title="All 2 branches missed.">        if (value == null)</span>
        {
<span class="nc" id="L554">            return containsNullValue();</span>
        }

<span class="nc bnc" id="L557" title="All 2 branches missed.">        for (Entry&lt;V&gt; entry : table)</span>
        {
<span class="nc bnc" id="L559" title="All 2 branches missed.">            for (Entry&lt;V&gt; e = entry; e != null; e = e.next)</span>
            {
<span class="nc bnc" id="L561" title="All 2 branches missed.">                if (value.equals(e.value))</span>
                {
<span class="nc" id="L563">                    return true;</span>
                }
            }
        }
<span class="nc" id="L567">        return false;</span>
    }

    /**
     * Special-case code for containsValue with null argument
     * 
     * @return boolean true if there is a null value in this map
     */
    private boolean containsNullValue()
    {
<span class="nc" id="L577">        Entry&lt;V&gt; tab[] = table;</span>
<span class="nc bnc" id="L578" title="All 2 branches missed.">        for (Entry&lt;V&gt; tabEntry : tab)</span>
        {
<span class="nc bnc" id="L580" title="All 2 branches missed.">            for (Entry&lt;V&gt; e = tabEntry; e != null; e = e.next)</span>
            {
<span class="nc bnc" id="L582" title="All 2 branches missed.">                if (e.value == null)</span>
                {
<span class="nc" id="L584">                    return true;</span>
                }
            }
        }
<span class="nc" id="L588">        return false;</span>
    }

    /**
     * Returns a shallow copy of this &lt;tt&gt;HashMap&lt;/tt&gt; instance: the keys and values themselves are
     * not cloned.
     * 
     * @return a shallow copy of this map.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    public Object clone() throws CloneNotSupportedException
    {
<span class="nc" id="L601">        IntHashMap&lt;V&gt; result = null;</span>
        try
        {
<span class="nc" id="L604">            result = (IntHashMap&lt;V&gt;)super.clone();</span>
<span class="nc" id="L605">            result.table = new Entry[table.length];</span>
<span class="nc" id="L606">            result.entrySet = null;</span>
<span class="nc" id="L607">            result.modCount.set(0);</span>
<span class="nc" id="L608">            result.size = 0;</span>
<span class="nc" id="L609">            result.init();</span>
<span class="nc" id="L610">            result.putAllForCreate(this);</span>
<span class="nc" id="L611">        }</span>
<span class="nc" id="L612">        catch (CloneNotSupportedException e)</span>
        {
            // assert false;
        }
<span class="nc" id="L616">        return result;</span>
    }

    /**
     * @author jcompagner
     * @param &lt;V&gt;
     *            type of value object
     */
    public static class Entry&lt;V&gt;
    {
        final int key;
        V value;
        Entry&lt;V&gt; next;

        /**
         * Create new entry.
         * 
         * @param k
         * @param v
         * @param n
         */
<span class="fc" id="L637">        Entry(final int k, final V v, final Entry&lt;V&gt; n)</span>
        {
<span class="fc" id="L639">            value = v;</span>
<span class="fc" id="L640">            next = n;</span>
<span class="fc" id="L641">            key = k;</span>
<span class="fc" id="L642">        }</span>

        /**
         * @return The int key of this entry
         */
        public int getKey()
        {
<span class="nc" id="L649">            return key;</span>
        }

        /**
         * @return Gets the value object of this entry
         */
        public V getValue()
        {
<span class="nc" id="L657">            return value;</span>
        }

        /**
         * @param newValue
         * @return The previous value
         */
        public V setValue(final V newValue)
        {
<span class="nc" id="L666">            V oldValue = value;</span>
<span class="nc" id="L667">            value = newValue;</span>
<span class="nc" id="L668">            return oldValue;</span>
        }

        /**
         * @see java.lang.Object#equals(java.lang.Object)
         */
        @SuppressWarnings(&quot;unchecked&quot;)
        @Override
        public boolean equals(final Object o)
        {
<span class="nc bnc" id="L678" title="All 2 branches missed.">            if (!(o instanceof Entry))</span>
            {
<span class="nc" id="L680">                return false;</span>
            }
<span class="nc" id="L682">            Entry&lt;V&gt; e = (Entry&lt;V&gt;)o;</span>
<span class="nc" id="L683">            int k1 = getKey();</span>
<span class="nc" id="L684">            int k2 = e.getKey();</span>
<span class="nc bnc" id="L685" title="All 2 branches missed.">            if (k1 == k2)</span>
            {
<span class="nc" id="L687">                Object v1 = getValue();</span>
<span class="nc" id="L688">                Object v2 = e.getValue();</span>
<span class="nc bnc" id="L689" title="All 6 branches missed.">                if ((v1 == v2) || ((v1 != null) &amp;&amp; v1.equals(v2)))</span>
                {
<span class="nc" id="L691">                    return true;</span>
                }
            }
<span class="nc" id="L694">            return false;</span>
        }

        /**
         * @see java.lang.Object#hashCode()
         */
        @Override
        public int hashCode()
        {
<span class="nc bnc" id="L703" title="All 2 branches missed.">            return key ^ (value == null ? 0 : value.hashCode());</span>
        }

        /**
         * @see java.lang.Object#toString()
         */
        @Override
        public String toString()
        {
<span class="nc" id="L712">            return getKey() + &quot;=&quot; + getValue(); //$NON-NLS-1$</span>
        }
    }

    /**
     * Add a new entry with the specified key, value and hash code to the specified bucket. It is
     * the responsibility of this method to resize the table if appropriate.
     * 
     * Subclass overrides this to alter the behavior of put method.
     * 
     * @param key
     * @param value
     * @param bucketIndex
     */
    void addEntry(final int key, final V value, final int bucketIndex)
    {
<span class="fc" id="L728">        table[bucketIndex] = new Entry&lt;&gt;(key, value, table[bucketIndex]);</span>
<span class="fc bfc" id="L729" title="All 2 branches covered.">        if (size++ &gt;= threshold)</span>
        {
<span class="fc" id="L731">            resize(2 * table.length);</span>
        }
<span class="fc" id="L733">    }</span>

    /**
     * Like addEntry except that this version is used when creating entries as part of Map
     * construction or &quot;pseudo-construction&quot; (cloning, deserialization). This version needn't worry
     * about resizing the table.
     * 
     * Subclass overrides this to alter the behavior of HashMap(Map), clone, and readObject.
     * 
     * @param key
     * @param value
     * @param bucketIndex
     */
    void createEntry(final int key, final V value, final int bucketIndex)
    {
<span class="nc" id="L748">        table[bucketIndex] = new Entry&lt;&gt;(key, value, table[bucketIndex]);</span>
<span class="nc" id="L749">        size++;</span>
<span class="nc" id="L750">    }</span>

    private abstract class HashIterator&lt;H&gt; implements Iterator&lt;H&gt;
    {
        Entry&lt;V&gt; next; // next entry to return
        int expectedModCount; // For fast-fail
        int index; // current slot
        Entry&lt;V&gt; current; // current entry

<span class="nc" id="L759">        HashIterator()</span>
<span class="nc" id="L760">        {</span>
<span class="nc" id="L761">            expectedModCount = modCount.get();</span>
<span class="nc" id="L762">            Entry&lt;V&gt;[] t = table;</span>
<span class="nc" id="L763">            int i = t.length;</span>
<span class="nc" id="L764">            Entry&lt;V&gt; n = null;</span>
<span class="nc bnc" id="L765" title="All 2 branches missed.">            if (size != 0)</span>
            { // advance to first entry
<span class="nc bnc" id="L767" title="All 4 branches missed.">                while ((i &gt; 0) &amp;&amp; ((n = t[--i]) == null))</span>
                {
                    /* NoOp */
                }
            }
<span class="nc" id="L772">            next = n;</span>
<span class="nc" id="L773">            index = i;</span>
<span class="nc" id="L774">        }</span>

        /**
         * @see java.util.Iterator#hasNext()
         */
        @Override
        public boolean hasNext()
        {
<span class="nc bnc" id="L782" title="All 2 branches missed.">            return next != null;</span>
        }

        Entry&lt;V&gt; nextEntry()
        {
<span class="nc bnc" id="L787" title="All 2 branches missed.">            if (!modCount.compareAndSet(expectedModCount, expectedModCount))</span>
            {
<span class="nc" id="L789">                throw new ConcurrentModificationException();</span>
            }
<span class="nc" id="L791">            Entry&lt;V&gt; e = next;</span>
<span class="nc bnc" id="L792" title="All 2 branches missed.">            if (e == null)</span>
            {
<span class="nc" id="L794">                throw new NoSuchElementException();</span>
            }

<span class="nc" id="L797">            Entry&lt;V&gt; n = e.next;</span>
<span class="nc" id="L798">            Entry&lt;V&gt;[] t = table;</span>
<span class="nc" id="L799">            int i = index;</span>
<span class="nc bnc" id="L800" title="All 4 branches missed.">            while ((n == null) &amp;&amp; (i &gt; 0))</span>
            {
<span class="nc" id="L802">                n = t[--i];</span>
            }
<span class="nc" id="L804">            index = i;</span>
<span class="nc" id="L805">            next = n;</span>
<span class="nc" id="L806">            return current = e;</span>
        }

        /**
         * @see java.util.Iterator#remove()
         */
        @Override
        public void remove()
        {
<span class="nc bnc" id="L815" title="All 2 branches missed.">            if (current == null)</span>
            {
<span class="nc" id="L817">                throw new IllegalStateException();</span>
            }
<span class="nc bnc" id="L819" title="All 2 branches missed.">            if (!modCount.compareAndSet(expectedModCount, expectedModCount))</span>
            {
<span class="nc" id="L821">                throw new ConcurrentModificationException();</span>
            }
<span class="nc" id="L823">            int k = current.key;</span>
<span class="nc" id="L824">            current = null;</span>
<span class="nc" id="L825">            removeEntryForKey(k);</span>
<span class="nc" id="L826">            expectedModCount = modCount.get();</span>
<span class="nc" id="L827">        }</span>

    }

<span class="nc" id="L831">    private class ValueIterator extends HashIterator&lt;V&gt;</span>
    {
        /**
         * @see java.util.Iterator#next()
         */
        @Override
        public V next()
        {
<span class="nc" id="L839">            return nextEntry().value;</span>
        }
    }

<span class="nc" id="L843">    private class KeyIterator extends HashIterator&lt;Integer&gt;</span>
    {
        /**
         * @see java.util.Iterator#next()
         */
        @Override
        public Integer next()
        {
<span class="nc" id="L851">            return nextEntry().getKey();</span>
        }
    }

<span class="nc" id="L855">    private class EntryIterator extends HashIterator&lt;Entry&lt;V&gt;&gt;</span>
    {
        /**
         * @see java.util.Iterator#next()
         */
        @Override
        public Entry&lt;V&gt; next()
        {
<span class="nc" id="L863">            return nextEntry();</span>
        }
    }

    // Subclass overrides these to alter behavior of views' iterator() method
    Iterator&lt;Integer&gt; newKeyIterator()
    {
<span class="nc" id="L870">        return new KeyIterator();</span>
    }

    Iterator&lt;V&gt; newValueIterator()
    {
<span class="nc" id="L875">        return new ValueIterator();</span>
    }

    Iterator&lt;Entry&lt;V&gt;&gt; newEntryIterator()
    {
<span class="nc" id="L880">        return new EntryIterator();</span>
    }

    // Views

<span class="pc" id="L885">    private transient Set&lt;Entry&lt;V&gt;&gt; entrySet = null;</span>

    /**
     * Returns a set view of the keys contained in this map. The set is backed by the map, so
     * changes to the map are reflected in the set, and vice-versa. The set supports element
     * removal, which removes the corresponding mapping from this map, via the
     * &lt;tt&gt;Iterator.remove&lt;/tt&gt;, &lt;tt&gt;Set.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt;, and
     * &lt;tt&gt;clear&lt;/tt&gt; operations. It does not support the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt;
     * operations.
     * 
     * @return a set view of the keys contained in this map.
     */
    public Set&lt;Integer&gt; keySet()
    {
<span class="nc" id="L899">        Set&lt;Integer&gt; ks = keySet;</span>
<span class="nc bnc" id="L900" title="All 2 branches missed.">        return (ks != null ? ks : (keySet = new KeySet()));</span>
    }

<span class="nc" id="L903">    private class KeySet extends AbstractSet&lt;Integer&gt;</span>
    {
        /**
         * @see java.util.AbstractCollection#iterator()
         */
        @Override
        public Iterator&lt;Integer&gt; iterator()
        {
<span class="nc" id="L911">            return newKeyIterator();</span>
        }

        /**
         * @see java.util.AbstractCollection#size()
         */
        @Override
        public int size()
        {
<span class="nc" id="L920">            return size;</span>
        }

        /**
         * @see java.util.AbstractCollection#contains(java.lang.Object)
         */
        @Override
        public boolean contains(final Object o)
        {
<span class="nc bnc" id="L929" title="All 2 branches missed.">            if (o instanceof Number)</span>
            {
<span class="nc" id="L931">                return containsKey(((Number)o).intValue());</span>
            }
<span class="nc" id="L933">            return false;</span>
        }

        /**
         * @see java.util.AbstractCollection#remove(java.lang.Object)
         */
        @Override
        public boolean remove(final Object o)
        {
<span class="nc bnc" id="L942" title="All 2 branches missed.">            if (o instanceof Number)</span>
            {
<span class="nc bnc" id="L944" title="All 2 branches missed.">                return removeEntryForKey(((Number)o).intValue()) != null;</span>
            }
<span class="nc" id="L946">            return false;</span>
        }

        /**
         * @see java.util.AbstractCollection#clear()
         */
        @Override
        public void clear()
        {
<span class="nc" id="L955">            IntHashMap.this.clear();</span>
<span class="nc" id="L956">        }</span>
    }

    /**
     * Returns a collection view of the values contained in this map. The collection is backed by
     * the map, so changes to the map are reflected in the collection, and vice-versa. The
     * collection supports element removal, which removes the corresponding mapping from this map,
     * via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;, &lt;tt&gt;Collection.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;,
     * &lt;tt&gt;retainAll&lt;/tt&gt;, and &lt;tt&gt;clear&lt;/tt&gt; operations. It does not support the &lt;tt&gt;add&lt;/tt&gt; or
     * &lt;tt&gt;addAll&lt;/tt&gt; operations.
     * 
     * @return a collection view of the values contained in this map.
     */
    public Collection&lt;V&gt; values()
    {
<span class="nc" id="L971">        Collection&lt;V&gt; vs = values;</span>
<span class="nc bnc" id="L972" title="All 2 branches missed.">        return (vs != null ? vs : (values = new Values()));</span>
    }

<span class="nc" id="L975">    private class Values extends AbstractCollection&lt;V&gt;</span>
    {
        /**
         * @see java.util.AbstractCollection#iterator()
         */
        @Override
        public Iterator&lt;V&gt; iterator()
        {
<span class="nc" id="L983">            return newValueIterator();</span>
        }

        /**
         * @see java.util.AbstractCollection#size()
         */
        @Override
        public int size()
        {
<span class="nc" id="L992">            return size;</span>
        }

        /**
         * @see java.util.AbstractCollection#contains(java.lang.Object)
         */
        @Override
        public boolean contains(final Object o)
        {
<span class="nc" id="L1001">            return containsValue(o);</span>
        }

        /**
         * @see java.util.AbstractCollection#clear()
         */
        @Override
        public void clear()
        {
<span class="nc" id="L1010">            IntHashMap.this.clear();</span>
<span class="nc" id="L1011">        }</span>
    }

    /**
     * Returns a collection view of the mappings contained in this map. Each element in the returned
     * collection is a &lt;tt&gt;Map.Entry&lt;/tt&gt;. The collection is backed by the map, so changes to the
     * map are reflected in the collection, and vice-versa. The collection supports element removal,
     * which removes the corresponding mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;,
     * &lt;tt&gt;Collection.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt;, and &lt;tt&gt;clear&lt;/tt&gt;
     * operations. It does not support the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations.
     * 
     * @return a collection view of the mappings contained in this map.
     * @see java.util.Map.Entry
     */
    public Set&lt;Entry&lt;V&gt;&gt; entrySet()
    {
<span class="nc" id="L1027">        Set&lt;Entry&lt;V&gt;&gt; es = entrySet;</span>
<span class="nc bnc" id="L1028" title="All 2 branches missed.">        return (es != null ? es : (entrySet = new EntrySet()));</span>
    }

<span class="nc" id="L1031">    private class EntrySet extends AbstractSet&lt;Entry&lt;V&gt;&gt;</span>
    {
        /**
         * @see java.util.AbstractCollection#iterator()
         */
        @Override
        public Iterator&lt;Entry&lt;V&gt;&gt; iterator()
        {
<span class="nc" id="L1039">            return newEntryIterator();</span>
        }

        /**
         * @see java.util.AbstractCollection#contains(java.lang.Object)
         */
        @SuppressWarnings(&quot;unchecked&quot;)
        @Override
        public boolean contains(final Object o)
        {
<span class="nc bnc" id="L1049" title="All 2 branches missed.">            if (!(o instanceof Entry))</span>
            {
<span class="nc" id="L1051">                return false;</span>
            }
<span class="nc" id="L1053">            Entry&lt;V&gt; e = (Entry&lt;V&gt;)o;</span>
<span class="nc" id="L1054">            Entry&lt;V&gt; candidate = getEntry(e.getKey());</span>
<span class="nc bnc" id="L1055" title="All 4 branches missed.">            return (candidate != null) &amp;&amp; candidate.equals(e);</span>
        }

        /**
         * @see java.util.AbstractCollection#remove(java.lang.Object)
         */
        @Override
        public boolean remove(final Object o)
        {
<span class="nc bnc" id="L1064" title="All 2 branches missed.">            return removeMapping(o) != null;</span>
        }

        /**
         * @see java.util.AbstractCollection#size()
         */
        @Override
        public int size()
        {
<span class="nc" id="L1073">            return size;</span>
        }

        /**
         * @see java.util.AbstractCollection#clear()
         */
        @Override
        public void clear()
        {
<span class="nc" id="L1082">            IntHashMap.this.clear();</span>
<span class="nc" id="L1083">        }</span>
    }

    /**
     * Save the state of the &lt;tt&gt;HashMap&lt;/tt&gt; instance to a stream (i.e., serialize it).
     * 
     * @param s
     *            The ObjectOutputStream
     * @throws IOException
     * 
     * @serialData The &lt;i&gt;capacity&lt;/i&gt; of the HashMap (the length of the bucket array) is emitted
     *             (int), followed by the &lt;i&gt;size&lt;/i&gt; of the HashMap (the number of key-value
     *             mappings), followed by the key (Object) and value (Object) for each key-value
     *             mapping represented by the HashMap The key-value mappings are emitted in the
     *             order that they are returned by &lt;tt&gt;entrySet().iterator()&lt;/tt&gt;.
     * 
     */
    private void writeObject(final java.io.ObjectOutputStream s) throws IOException
    {
        // Write out the threshold, loadfactor, and any hidden stuff
<span class="nc" id="L1103">        s.defaultWriteObject();</span>

        // Write out number of buckets
<span class="nc" id="L1106">        s.writeInt(table.length);</span>

        // Write out size (number of Mappings)
<span class="nc" id="L1109">        s.writeInt(size);</span>

        // Write out keys and values (alternating)
<span class="nc bnc" id="L1112" title="All 2 branches missed.">        for (Entry&lt;V&gt; entry : entrySet())</span>
        {
<span class="nc" id="L1114">            s.writeInt(entry.getKey());</span>
<span class="nc" id="L1115">            s.writeObject(entry.getValue());</span>
        }
<span class="nc" id="L1117">    }</span>

    private static final long serialVersionUID = 362498820763181265L;

    /**
     * Reconstitute the &lt;tt&gt;HashMap&lt;/tt&gt; instance from a stream (i.e., deserialize it).
     * 
     * @param s
     * @throws IOException
     * @throws ClassNotFoundException
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    private void readObject(final java.io.ObjectInputStream s) throws IOException,
        ClassNotFoundException
    {
<span class="nc" id="L1132">        modCount = new AtomicInteger(0);</span>

        // Read in the threshold, loadfactor, and any hidden stuff
<span class="nc" id="L1135">        s.defaultReadObject();</span>

        // Read in number of buckets and allocate the bucket array;
<span class="nc" id="L1138">        int numBuckets = s.readInt();</span>
<span class="nc" id="L1139">        table = new Entry[numBuckets];</span>

<span class="nc" id="L1141">        init(); // Give subclass a chance to do its thing.</span>

        // Read in size (number of Mappings)
<span class="nc" id="L1144">        int size = s.readInt();</span>

        // Read the keys and values, and put the mappings in the HashMap
<span class="nc bnc" id="L1147" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++)</span>
        {
<span class="nc" id="L1149">            int key = s.readInt();</span>
<span class="nc" id="L1150">            V value = (V)s.readObject();</span>
<span class="nc" id="L1151">            putForCreate(key, value);</span>
        }
<span class="nc" id="L1153">    }</span>

    // These methods are used when serializing HashSets
    int capacity()
    {
<span class="nc" id="L1158">        return table.length;</span>
    }

    float loadFactor()
    {
<span class="nc" id="L1163">        return loadFactor;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span>HashMapTest.testSingleAdd (29.05.2019 13:08:27)</div></body></html>